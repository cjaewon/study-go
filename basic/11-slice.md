# 🍕 Slice
동적배열로 원소가 추가될때 마다 기존 원소들을 복사하고 새로운 원소를 합쳐서 활당하는 방식이다.  
> 원소를 합칠때 성능저하를 막기위해서 합친 원소의 수보다 더 많이 활당한다.

```go
var a []int
b := []int{1, 2, 3, 4}
c := make([]int, 3)
d := make([]int, 3, 6) // []int, [길이], [cap]

fmt.Println(len(d), cap(d)) // 3 6

a = append(a, 1) // 값 push
```

## 자르기 ( slice )
`a[start-index:end-index]` 형태로 자르기가 가능하다.

```go
var a []int = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

fmt.Println(a[1:5]) // [2 3 4 5]
fmt.Println(a[:5]) // [1 2 3 4 5]
fmt.Println(a[5:]) // [6 7 8 9 10]
```

슬라이스를 하면 새로운 슬라이스를 만드는 것이 아닌 가르키고 있다.

```go
var a []int = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
b := a[1:2] // b 는 a 를 가르킴
b[1] = 0
b[2] = 0

fmt.Println(b) // 1, 0, 0, 3, 4, 5, 6, 7, 8, 9, 10
```

## 심화
slice 는 배열을 주소로 가지고 있기 때문에 밑에 상황에서는 주소로 넘겨진다.
```go
x := []int{1, 2, 3, 4}
y := x

y[0] = 100

fmt.Println(x) // [100, 2, 3, 4]
```

append 또한 cap과 len 에 따라서 기존 배열의 포인터를 넘기거나 새롭게 생긴 배열의 포인터를 넘긴다.

